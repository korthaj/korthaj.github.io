<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Java to Go in-depth tutorial - yourbasic.org/golang </title>
  <meta name="description" content="A tutorial to help Java programmers come up to speed quickly with Go. It compares the languages and offers plenty of code examples.">
  
  <link rel="stylesheet" href="/style.css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i&amp;subset=latin-ext" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,700,700i&amp;subset=latin-ext" rel="stylesheet">
  <link rel="icon" type="image/png" href="/res/favicon-16x16.png">
  <link rel="icon" type="image/png" href="/res/favicon-32x32.png">
  <link rel="icon" type="image/png" href="/res/favicon-96x96.png">
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113104149-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-113104149-1');
  </script>

  <script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://yourbasic.org/golang/go-java-tutorial/"
  },
  "headline": "Java to Go in-depth tutorial",
  "image": [
    "https://yourbasic.org/golang/gopher-latte.jpg"
   ],
  "datePublished": "2018-01-26T00:00:00&#43;0000",
  "dateModified": "2018-03-30T00:00:00&#43;0000",
  "author": {
    "@type": "Person",
    "name": "Stefan Nilsson"
  },
   "publisher": {
    "@type": "Organization",
    "name": "yourbasic.org",
    "logo": {
      "@type": "ImageObject",
      "url": "https://yourbasic.org/res/favicon-96x96.png"
    }
  },
  "description": "A tutorial to help Java programmers come up to speed quickly with Go. It compares the languages and offers plenty of code examples."
}
</script>

<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Java to Go in-depth tutorial">
<meta property="og:description" content="A tutorial to help Java programmers come up to speed quickly with Go. It compares the languages and offers plenty of code examples.">
<meta property="og:url" content="https://yourbasic.org/golang/go-java-tutorial/">
<meta property="og:image" content="https://yourbasic.org/golang/gopher-latte.jpg">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Java to Go in-depth tutorial">
<meta name="twitter:description" content="A tutorial to help Java programmers come up to speed quickly with Go. It compares the languages and offers plenty of code examples.">
<meta name="twitter:site" content="@yourbasic_org">
<meta name="twitter:image" content="https://yourbasic.org/golang/gopher-latte.jpg">


</head>

<body>
<header>
  <nav>
    <ul>
      <li><a href="/about/">About</a></li>
      <li><a href="/">Home</a></li>
      <li><a href="/algorithms/">Algorithms</a></li>
      <li class="here"><a href="/golang/">Go</a></li>
    </ul>
  </nav>
</header>

<main>
<article>
<h1>Java to Go in-depth tutorial</h1>
<div class="tagline">yourbasic.org/golang</div>



<!-- CC BY-SA 2.0: https://www.flickr.com/photos/yukop/6779040884 -->

<div class="extra-content"><img src="/golang/gopher-latte.jpg" width="200px" style="float: right; margin: 20px 0 0 20px;"></div>

<p class="lead">This tutorial is in&shy;tended to help Java deve&shy;lopers come up to speed quickly with&nbsp;Go.</p>

<div style="margin-top: 1em"></div>
<div style="float: left; min-width: 30%; margin-right: 2em;">
    <ul class="toc" style="margin: 0;">
        <li><a href="#hello-stack-example">Hello stack (example)</a></li>
        <li><a href="#main-differences">Main differences</a></li>
        <li><a href="#syntax">Syntax</a></li>
        <li><a href="#constants">Constants</a></li>
        <li><a href="#structs">Structs</a></li>
        <li><a href="#pointers">Pointers</a></li>
        <li><a href="#slices">Slices</a></li>
    </ul>
</div>
<div style="float: left;">
    <ul class="toc" style="margin: 0;">
        <li><a href="#making-values">Making values</a></li>
        <li><a href="#methods-and-interfaces">Methods and interfaces</a></li>
        <li><a href="#errors">Errors</a></li>
        <li><a href="#panic-and-recover">Panic and recover</a></li>
        <li><a href="#goroutines-and-channels">Goroutines and channels</a></li>
        <li><a href="#hello-server-example">Hello server (example)</a></li>
    </ul>
</div>
<div style="clear: both"></div>

<h2 id="hello-stack-example">Hello stack (example)</h2>

<p>Let&rsquo;s start with a small but complete example. It shows how to implement and use a simple abstract data type in Go.</p>

<pre><code><span class="comment">// Package collection implements a stack of strings.</span>
package collection

<span class="comment">// The zero value for Stack is an empty stack ready to use.</span>
type Stack struct {
    data []string
}

<span class="comment">// Push adds x to the top of the stack.</span>
func (s *Stack) Push(x string) {
    s.data = append(s.data, x)
}

<span class="comment">// Pop removes and returns the top element of the stack.
// It’s a run-time error to call Pop on an empty stack.</span>
func (s *Stack) Pop() string {
    n := len(s.data) - 1
    res := s.data[n]
    s.data[n] = "" <span class="comment">// to avoid memory leak</span>
    s.data = s.data[:n]
    return res
}

<span class="comment">// Size returns the number of elements in the stack.</span>
func (s *Stack) Size() int {
    return len(s.data)
}</code></pre>

<ul>
<li>Comments that appear directly before top-level declarations are
    documentation comments. They are written in plain text.
</li>
<li>For declarations, your write the name followed by the type.
</li>
<li>A <code>struct</code> corresponds to a class in Java,
    but the members of a struct cannot be methods, only variables.
</li>
<li>The code fragment <code>(s&nbsp;*Stack)</code>
    declares a method receiver&nbsp;<code>s</code>
    corresponding to Java’s <code>this</code>.
</li>
<li>The operator <code>:=</code> both declares and initializes a variable.
    Its type is deduced from the initialization expression.
</li>
</ul>

<p>Here is a Hello world program, which shows how to use
the <code>collection.Stack</code> abstract data type.</p>

<pre><code>package collection_test

import (
    "fmt"
    "go-for-java-programmers/collection"
)

func ExampleStack() {
    var s collection.Stack
    s.Push("world!")
    s.Push("Hello, ")
    for s.Size() > 0 {
        fmt.Print(s.Pop())
    }
    fmt.Println()
    <span class="comment">// Output: Hello, world!</span>
}</code></pre>

<ul>
<li><p>The test package <code>collection_test</code> resides in the same directory
as the <code>collection</code> package.</p></li>

<li><p>The first import declaration contains the path <code>&ldquo;fmt&rdquo;</code> to  a standard package;
the second one indicates that we will use the package from
the directory <code>&ldquo;go-for-java-programmers/collection&rdquo;</code>.</p></li>

<li><p>The packages are accessed within the source file by the short names
<code>fmt</code> and <code>collection</code>, respectively.</p></li>
</ul>

<blockquote>
<p><strong>Note:</strong> The idiomatic way to implement a stack in Go is to use a slice directly.
See, <a href="/golang/implement-stack/">Implement a stack (LIFO)</a>.</p>
</blockquote>

<h2 id="main-differences">Main differences</h2>

<h3 id="object-oriented-programming">Object-oriented programming</h3>

<ul>
<li>Go does not have classes with constructors.
Instead of instance methods, a class inheritance hierarchy,
and dynamic method lookup, Go provides
<a href="/golang/structs-explained/">structs</a> and <a href="/golang/interfaces-explained/">interfaces</a>.</li>
<li>Go allows <a href="/golang/methods-explained/">methods</a> on any type; no boxing is required.
The method <em>receiver</em>, which corresponds to&nbsp;<code>this</code> in&nbsp;Java,
can be a direct value or a pointer.</li>
<li>Go provides <a href="/golang/public-private/">two&nbsp;access&nbsp;levels</a>,
analogous to Java’s public and package-private. Top-level declarations
are public if their names start with an upper-case letter,
otherwise they are package-private.</li>
</ul>

<h3 id="functional-programming">Functional programming</h3>

<ul>
<li>Functions in Go are first class citizens.
<a href="/golang/function-pointer-type-declaration/">Function values</a> can be used and passed around
just like other values and <a href="/golang/anonymous-function-literal-lambda-closure/">function literals</a>
may refer to variables defined in a enclosing function.</li>
</ul>

<h3 id="pointers-and-references">Pointers and references</h3>

<ul>
<li>Go offers <a href="/golang/pointers-explained/">pointers</a> to values of all types,
not just objects and arrays.
For any type&nbsp;<code>T</code>, there is a corresponding pointer type&nbsp;<code>*T</code>,
denoting pointers to values of type&nbsp;<code>T</code>.</li>
<li>Go uses <code>nil</code> for invalid pointers, where Java uses <code>null</code>.</li>
<li>Arrays in Go are values. When an array is used as a
function parameter, the function receives a copy of the array,
not a pointer to it. However, in practice functions often use
<a href="/golang/slices-explained/">slices</a> for parameters;
slices are references to underlying arrays.</li>
<li>Certain types (maps, slices, and channels) are passed by reference,
not by value. That is, passing a map to a function does not copy the map;
if the function changes the map, the change will be seen by the caller.
In Java terms, one can think of this as being a reference to the map.</li>
</ul>

<h3 id="built-in-types">Built-in types</h3>

<ul>
<li>Strings are provided by the language;
a <a href="/golang/string-functions-reference-cheat-sheet/">string</a> behaves like a
slice of bytes, but is immutable.</li>
<li>Hash tables are provided by the language.
They are called <a href="/golang/maps-explained/">maps</a>.</li>
</ul>

<h3 id="error-handling">Error handling</h3>

<ul>
<li>Instead of exceptions, Go uses <a href="/golang/errors-explained/">errors</a>
to signify events such as end-of-file,
and run-time <a href="/golang/panic-explained/">panics</a> for run-time errors
such as attempting to index an array out of bounds.</li>
</ul>

<h3 id="concurrency">Concurrency</h3>

<ul>
<li>Separate threads of execution, <a href="/golang/goroutines-explained/">goroutines</a>,
and communication channels between them, <a href="/golang/channels-explained/">channels</a>,
are provided by the language.</li>
</ul>

<h3 id="absent-features">Absent features</h3>

<ul>
<li>Go does not support implicit type conversion. Operations that mix
different types require an explicit conversion.
Instead Go offers <a href="/golang/untyped-constants/">Untyped numeric constants with no limits</a>.</li>
<li>Go does not support function overloading. Functions and methods in the same scope must have unique names.
For alternatives, see <a href="/golang/overload-overwrite-optional-parameter/">Optional parameters and method overloading</a>.</li>
<li>Go has some built-in generic data types, such as slices and maps,
and generic functions, such as append and copy.
However, there is no mechanism for writing your own generic functions.
For alternatives, see <a href="/golang/generics/">Generics (alternatives and workarounds)</a>.</li>
</ul>

<h2 id="syntax">Syntax</h2>

<!-- http://www.flickr.com/photos/ruminatrix/3052493260/" -->

<p><img src="/golang/syntax-terror.jpg" alt="Syntax Terror"></p>

<h3 id="declarations">Declarations</h3>

<p>The declaration syntax is reversed compared to Java.
You write the name followed by the type.
Type declarations may be read easily from left to right.</p>

<table class="white">
<tr>
<th>Go</th>
<th>Approximate Java equivalent</th>
</tr>
<tr>
<td><code>var v1 int</code></td>
<td><code>int v1 = 0;</code></td>
</tr>
<tr>
<td><code>var v2 *int</code></td>
<td><code>Integer v2 = null;</code></td>
</tr>
<tr>
<td><code>var v3 string</code></td>
<td><code>String v3 = "";</code></td>
</tr>
<tr>
<td><code>var v4 [10]int</code></td>
<td><code>int[] v4 = new&nbsp;int[10];</code><br>(Arrays are values in Go.)</td>
</tr>
<tr>
<td><code>var v5 []int</code></td>
<td><code>int[] v5 = null;</code></td>
</tr>
<tr>
<td><code>var v6 *struct{ a&nbsp;int&nbsp;}</code></td>
<td><code>class C { int&nbsp;a; }</code><br><code>C v6 = null;</code></td>
</tr>
<tr>
<td><code>var v7 map[string]int</code></td>
<td><code>HashMap&lt;String, Integer&gt;&nbsp;v7;</code><br><code>v7 = null;</code></td>
</tr>
<tr>
<td><code>var v8 func(a&nbsp;int)&nbsp;int</code></td>
<td><code>interface F {<br>&nbsp;&nbsp;int f(int&nbsp;a);<br>}</code><br><code>F v8 = null;</code></td>
</tr>
</table>

<p>Declarations generally take the form of a keyword followed by the name
of the object being declared. The keyword is one of <code>const</code>,
<code>type</code>, <code>var</code>, or <code>func</code>.
You can also use a keyword followed by a series of declarations in
parentheses.</p>

<pre><code>var (
    n int
    x float64
)
</code></pre>

<p>When declaring a function, you must either provide a name for each parameter
or not provide a name for any parameter; you can’t omit some names
and provide others.  You may group several names with the same type.</p>

<pre><code>func f(i, j, k int, s, t string)
</code></pre>

<p>A variable may be initialized when it is declared.  When this is done,
specifying the type of the variable is permitted but not required.
When the type is not specified, it defaults to the type of
the initialization expression.</p>

<pre><code>var v9 = *v2
</code></pre>

<p>If a variable is not initialized explicitly, the type must be specified.
In that case it will be implicitly initialized to the type’s
<a href="/golang/default-zero-value/">zero value</a>
(<code>0</code>, <code>nil</code>, <code>&rdquo;&rdquo;</code>, etc.).
There are no uninitialized variables in&nbsp;Go.</p>

<h3 id="short-declarations">Short declarations</h3>

<p>Within a function, a short declaration syntax is available
with&nbsp;<code>:=</code>&nbsp;.
The statement</p>

<pre><code>v10 := v1
</code></pre>

<p>is the same as</p>

<pre><code>var v10 = v1
</code></pre>

<h3 id="function-types">Function types</h3>

<p>In Go, functions are first-class citizens.
Go’s <a href="/golang/function-pointer-type-declaration/">function&nbsp;type</a> denotes the set of all functions
with the same parameter and result types.</p>

<pre><code>type binOp func(int, int) int

var op binOp
add := func(i, j int) int { return i + j }

op = add
n = op(100, 200)  <span class="comment">// n = 100 + 200</span></code></pre>

<h3 id="multiple-assignment">Multiple assignment</h3>

<p>Go permits multiple assignments.
The expressions on the right are evaluated
before assigning to any of the operands on the left.</p>

<pre><code>i, j = j, i  <span class="comment">// Swap i and j.</span></code></pre>

<p>Functions may have multiple return values, indicated by a list in
parentheses.  The returned values can be stored by assignment
to a list of variables.</p>

<pre><code>func f() (i int, pj *int) { ... }
v1, v2 = f()
</code></pre>

<h3 id="the-blank-identifier">The blank identifier</h3>

<p>The <a href="/golang/underscore/">blank&nbsp;identifier</a>, represented by the underscore character,
provides a way to ignore values returned by a multi-valued expression:</p>

<pre><code>v1, _ = f()  <span class="comment">// Ignore second value returned by f().</span></code></pre>

<h3 id="semicolons-and-formatting">Semicolons and formatting</h3>

<p>Instead of worrying about semicolons and formatting, you may use
the <code>gofmt</code> program to produce a single standard Go style.
While this style may initially seem odd, it is as good as any other style,
and familiarity will lead to comfort.</p>

<p>Go code uses very few semicolons in practice. Technically, all Go
statements are terminated by a semicolon. However, Go
implicitly inserts a semicolon at the end of a non-blank line
unless the line is clearly incomplete.
A consequence of this is that in some cases Go does not permit a line break.
For example, you may not write</p>

<pre><code>func g()
{            <span class="comment">// <b>INVALID:</b> "{" should be on previous line.</span>
}</code></pre>

<p>A semicolon will be inserted after <code>g()</code>
causing it to be a function declaration rather than a function definition.
Similarly, you may not write</p>

<pre><code>if n == 0 {
}
else {       <span class="comment">// <b>INVALID:</b> "else {" should be on previous line.</span>
}</code></pre>

<p>A semicolon will be inserted after the <code>}</code> preceding
the <code>else</code>, causing a syntax error.</p>

<h3 id="conditional-statements">Conditional statements</h3>

<p>Go does not use parentheses around the condition of
an <code>if</code> statement,
or the expressions of a <code>for</code> statement,
or the value of a <code>switch</code> statement.
On the other hand, it does require curly braces around
the body of an <code>if</code> or <code>for</code> statement.</p>

<pre><code>if a < b { f() }
if (a < b) { f() }          <span class="comment">// Parentheses are unnecessary.</span>
if (a < b) f()              <span class="comment">// <b>INVALID</b></span>
for i = 0; i < 10; i++ {}
for (i = 0; i < 10; i++) {} <span class="comment">// <b>INVALID</b></span></code></pre>

<p>Furthermore, <code>if</code> and <code>switch</code> accept
an optional initialization statement, which is commonly used
to set up a local variable.</p>

<pre><code>if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
</code></pre>

<h3 id="for-statements">For statements</h3>

<p>Go does not have a <code>while</code> statement
nor does it have a <code>do-while</code> statement.
The <a href="/golang/for-loop/">for&nbsp;statement</a> may be used with a single condition,
which makes it equivalent to a <code>while</code> statement.
Omitting the condition entirely produces an endless loop.</p>

<p>A <code>for</code> statement may contain a <code>range</code> clause
for iterating over strings, arrays, slices, maps, or channels.
Instead of writing</p>

<pre><code>for i := 0; i &lt; len(a); i++ { ... }
</code></pre>

<p>to loop over the elements of <code>a</code>, we could also write</p>

<pre><code>for i, v := range a { ... }
</code></pre>

<p>This assigns <code>i</code> to the index and <code>v</code>
to the value of the successive elements of an array, slice, or string.</p>

<ul>
<li>For strings, <code>i</code> is an index to a byte and
<code>v</code> is a Unicode code point of type <code>rune</code>
(<code>rune</code> is an alias for <code>int32</code>).</li>
<li>Iterations over maps produce key-value pairs,
while channels produce only one iteration value.</li>
</ul>

<h3 id="break-and-continue">Break and continue</h3>

<p>Like Java, Go permits <code>break</code> and <code>continue</code>
to specify a label, but the label must refer to a <code>for</code>,
<code>switch</code>, or <code>select</code> statement.</p>

<h3 id="switch-statements">Switch statements</h3>

<p>In a <a href="/golang/switch-statement/">switch&nbsp;statement</a>, <code>case</code> labels
do not fall through by default,
but you can make them fall through by ending a case
with a <code>fallthrough</code> statement.</p>

<pre><code>switch n {
case 0: <span class="comment">// empty case body</span>
case 1:
    f() <span class="comment">// f is not called when n == 0.</span>
}</code></pre>

<p>But a <code>case</code> can have multiple values.</p>

<pre><code>switch n {
case 0, 1:
    f() <span class="comment">// f is called if n == 0 || n == 1.</span>
}</code></pre>

<p>The values in a <code>case</code> can be any type that supports
the equality comparison operator, such as strings or pointers.
A missing switch expression is equivalent to
the expression <code>true</code>.</p>

<pre><code>switch {
case n &lt; 0:
    f1()
case n == 0:
    f2()
default:
    f3()
}
</code></pre>

<h3 id="increment-and-decrement">Increment and decrement</h3>

<p>The <code>++</code> and <code>-&#8202;-</code> may only be used
as postfix operators and only in statements, not in expressions.
For example, you cannot write <code>n = i++</code>.</p>

<h3 id="defer-statement">Defer statement</h3>

<p>A <a href="/golang/defer/">defer&nbsp;statement</a> invokes a function whose execution is
deferred to the moment the surrounding function returns.</p>

<ul>
<li>The deferred function will be executed regardless of which path
the surronding function takes to return.</li>
<li>The parameters of the deferred function, however, are computed and saved
for future use already when the defer statement executes.</li>
</ul>

<pre><code>f, err := os.Open("filename")
defer f.Close() <span class="comment">// f will be closed when this function returns.</span></code></pre>

<h2 id="constants">Constants</h2>

<p>In Go constants may be <a href="/golang/untyped-constants/">untyped</a>. This applies to</p>

<ul>
<li>numeric literals,</li>
<li>expressions using only untyped constants,</li>
<li>and <code>const</code> declarations where no type is given and
the initializer expression is untyped.</li>
</ul>

<p>A value derived from an untyped constant becomes typed when it
is used within a context that requires a typed value.
This permits constants to be used relatively freely even though
Go has no implicit type conversion.</p>

<pre><code>var a uint
f(a + 1)   <span class="comment">// The untyped numeric constant 1 becomes typed as uint.</span>
f(a + 1e3) <span class="comment">// 1e3 is also typed as uint.</span></code></pre>

<p>The language does not impose any limits on the size of an untyped
numeric constant. A limit is only applied when a constant is used
where a type is required.</p>

<pre><code>const huge = 1 &lt;&lt; 100
var n int = huge &gt;&gt; 98
</code></pre>

<p>If the type is absent in a variable declaration and the corresponding
expression evaluates to an untyped numeric constant,
the constant is converted to type <code>rune</code>, <code>int</code>,
<code>float64</code>, or <code>complex128</code> respectively,
depending on whether the value is a character, integer, floating-point, or
complex constant.</p>

<pre><code>c := 'å'    <span class="comment">// rune (alias for int32)</span>
n := 1 + 2  <span class="comment">// int</span>
x := 2.7    <span class="comment">// float64</span>
z := 1 + 2i <span class="comment">// complex128</span></code></pre>

<p>Go does not have <a href="/golang/define-enumeration-string/">enumerated&nbsp;types</a>.
Instead, you can use the special name <a href="/golang/iota/"><code>iota</code></a> in a single
<code>const</code> declaration to get a series of increasing value.
When an initialization expression is omitted for a <code>const</code>,
it reuses the preceding expression.</p>

<pre><code>const (
    red = iota <span class="comment">// red == 0</span>
    blue       <span class="comment">// blue == 1</span>
    green      <span class="comment">// green == 2</span>
)</code></pre>

<h2 id="structs">Structs</h2>

<p>A <a href="/golang/structs-explained/">struct</a> corresponds to a class in Java, but the members of a struct
cannot be methods, only variables.
A pointer to a struct is similar to a reference variable in Java.
As opposed to Java classes, structs may also be defined as direct values.
In both cases you use <code>.</code> to access the members of a struct.</p>

<pre><code>type MyStruct struct {
    s string
    n int64
}

var x MyStruct     <span class="comment">// x is initialized to MyStruct{"", 0}.</span>
var px *MyStruct   <span class="comment">// px is initialized to nil.</span>
px = new(MyStruct) <span class="comment">// px points to the new struct MyStruct{"", 0}.</span>

x.s = "Foo"
px.s = "Bar"</code></pre>

<p>In Go, methods may be associated with any user-defined type, not just with structs;
see the section <a href="#methods-and-interfaces">Methods and interfaces</a>.</p>

<h2 id="pointers">Pointers</h2>

<!-- http://www.flickr.com/photos/lwr/374707207/" -->

<div><img src="/golang/pointers.jpg" style="float: right; width: 160px; margin: 0 0 20px 20px;"></div>

<p>If&nbsp;you have an int, a struct or an array,
assign&shy;ment copies the contents of the object.
To achieve the effect of Java reference variables, Go uses <a href="/golang/pointers-explained/">pointers</a>.</p>

<p>For any type&nbsp;<code>T</code>, there is a corresponding
pointer type&nbsp;<code>*T</code>,
denoting pointers to values of type&nbsp;<code>T</code>.</p>

<p>To allocate storage for a pointer variable,
use the built-in function <code>new</code>,
which takes a type and returns a pointer to the allocated storage.
The allocated space will be zero-initialized for the type.
For example, <code>new(int)</code> allocates storage
for a new&nbsp;<code>int</code>,
initializes it with the value&nbsp;<code>0</code>,
and returns its address, which has type&nbsp;<code>*int</code>.</p>

<p>The Java code <code>T&nbsp;p&nbsp;=&nbsp;new&nbsp;T()</code>,
where <code>T</code> is a class with two instance variables
<code>a</code> and <code>b</code> of type <code>int</code>,
corresponds to</p>

<pre><code>type T struct { a, b int }
var p *T = new(T)
</code></pre>

<p>or the more idiomatic</p>

<pre><code>p := new(T)
</code></pre>

<p>The declaration <code>var&nbsp;v&nbsp;T</code>,
which declares a variable that holds a value of type&nbsp;<code>T</code>,
has no equivalent in Java.
Values can also be created and initialized using a <em>composite literal</em>.
For example:</p>

<pre><code>v := T{1, 2}
</code></pre>

<p>is equivalent to</p>

<pre><code>var v T
v.a = 1
v.b = 2
</code></pre>

<p>For an operand <code>x</code> of type&nbsp;<code>T</code>,
the <em>address operator</em> <code>&amp;x</code>
gives the address of <code>x</code>, a value of type&nbsp;<code>*T</code>.
For example:</p>

<pre><code>p := &T{1, 2} <span class="comment">// p has type *T</span></code></pre>

<p>For an operand <code>x</code> of pointer type,
the <em>pointer indirection</em> <code>*x</code>
denotes the value pointed to by&nbsp;<code>x</code>.
Pointer indirections are rarely used;
Go, just like Java, can automatically take the address of a variable.</p>

<pre><code>p := new(T)
p.a = 1 <span class="comment">// equivalent to (*p).a = 1</span></code></pre>

<h2 id="slices">Slices</h2>

<p>A <a href="/golang/slices-explained/">slice</a> is conceptually a struct with three fields:</p>

<ul>
<li>a pointer into an array,</li>
<li>a length,</li>
<li>and a capacity.</li>
</ul>

<p>Slices support the <code>[]</code> operator
to access elements of the underlying array.</p>

<ul>
<li>The built-in <code>len</code> function returns the length of the slice.</li>
<li>The built-in <code>cap</code> function returns the capacity.</li>
</ul>

<p>Given an array, or another slice, a new slice is created via
<code>a[i:j]</code>.</p>

<ul>
<li>This creates a new slice which refers to&nbsp;<code>a</code>,
starts at index&nbsp;<code>i</code>, and ends before index&nbsp;<code>j</code>.</li>
<li>It has length <code>j&nbsp;-&nbsp;i</code>.</li>
<li>If <code>i</code> is omitted, the slice starts at&nbsp;<code>0</code>.</li>
<li>If <code>j</code> is omitted, the slice ends at&nbsp;<code>len(a)</code>.</li>
</ul>

<p>The new slice refers to the same array to which <code>a</code> refers.
That is, changes made to the elements using the new slice
may be seen using <code>a</code>.</p>

<p>The capacity of the new slice is simply the capacity of <code>a</code>
minus <code>i</code>.
The capacity of an array is the length of the array.</p>

<pre><code>var s []int
var a [10]int

s = a[:] <span class="comment">// short for s = a[0:len(a)]</span></code></pre>

<p>If you create a value of type <code>[100]byte</code>
(an array of 100&nbsp;bytes, perhaps a buffer)
and you want to pass it to a function without copying it,
declare the function parameter to have type <code>[]byte</code>,
and pass a slice of the array.
Slices may also be created using the <code>make</code> function
as <a href="#making-values">described below</a>.</p>

<p>Slices combined with the built-in function <code>append</code> offer
much the same functionality as Java’s <code>ArrayList</code>.</p>

<pre><code>s0 := []int{1, 2}
s1 := append(s0, 3)     <span class="comment">// append a single element</span>
s2 := append(s1, 4, 5)  <span class="comment">// append multiple elements</span>
s3 := append(s2, s0...) <span class="comment">// append a slice</span></code></pre>

<p>The slice syntax may also be used with a string. It returns a new string
whose value is a substring of the original string.</p>

<h2 id="making-values">Making values</h2>

<p>Map and channel values must be allocated using the built-in
<a href="/golang/make-slice-map-channel/"><code>make</code></a> function. For example, calling</p>

<pre><code>make(map[string]int)
</code></pre>

<p>returns a newly allocated value of type <code>map[string]int</code>.</p>

<p>As opposed to <code>new</code>, <code>make</code> returns
the actual object, not an address. This is consistent with the fact
that maps and channels are reference types.</p>

<p>For maps, make takes a capacity hint as an optional second argument.</p>

<p>For channels, there is an optional second argument that sets the
buffering capacity of the channel; the default is&nbsp;0 (unbuffered).</p>

<p>The <code>make</code> function may also be used to allocate a slice.
In this case it allocates memory for the underlying array and returns
a slice referring to it.
There is one required argument, which is the number of elements in the slice.
A second optional argument is the capacity of the slice.</p>

<pre><code>m := make([]int, 10, 20) <span class="comment">// Same as new([20]int)[:10]</span></code></pre>

<h2 id="methods-and-interfaces">Methods and interfaces</h2>

<p>A <a href="/golang/methods-explained/">method</a> looks like an ordinary function definition,
except that it has a <em>receiver</em>.
The receiver is similar to the <code>this</code> reference
in a Java instance method.</p>

<pre><code>type MyType struct { i int }

func (p *MyType) Get() int {
    return p.i
}

var pm = new(MyType)
var n = pm.Get()
</code></pre>

<p>This declares a method <code>Get</code> associated with <code>MyType</code>.
The receiver is named <code>p</code> in the body of the function.</p>

<p>Methods are declared on <em>defined types</em>. If you convert the value
to a different type, the new value will have the methods of the new type,
not those of the old type.</p>

<p>You may define methods on a built-in type by declaring a new defined type
derived from it. The new type is distinct from the built-in type.</p>

<pre><code>type MyInt int

func (p MyInt) Get() int {
    return int(p) <span class="comment">// The conversion is required.</span>
}

func f(i int) {}
var v MyInt

v = v * v <span class="comment">// The operators of the underlying type still apply.</span>
f(int(v)) <span class="comment">// int(v) has no declared methods.</span>
f(v)      <span class="comment">// <b>INVALID</b></span></code></pre>

<h3 id="interfaces">Interfaces</h3>

<p>A Go <a href="/golang/interfaces-explained/">interface</a> is similar to a Java interface,
but any type that provides the methods named in a Go interface
may be treated as an implementation of that interface.
No explicit declaration is required.</p>

<p>Let&rsquo;s assume that this interface is defined:</p>

<pre><code>type MyInterface interface {
    Get() int
    Set(i int)
}
</code></pre>

<p>Since <code>MyType</code> already has a <code>Get</code>&nbsp;method,
we can make <code>MyType</code> satisfy the interface by adding</p>

<pre><code>func (p *MyType) Set(i int) {
    p.i = i
}
</code></pre>

<p>Now any function which takes <code>MyInterface</code> as a parameter
will accept a variable of type <code>*MyType</code>.</p>

<pre><code>func GetAndSet(x MyInterface) {}

func f1() {
    var p MyType
    GetAndSet(&amp;p)
}
</code></pre>

<p>In Java terms, defining <code>Set</code> and <code>Get</code> for
<code>*MyType</code> made <code>*MyType</code> automatically implement
<code>MyInterface</code>. A type may satisfy multiple interfaces.
This is a form of duck typing.</p>

<p><em>
When I see a bird that walks like a&nbsp;duck and swims
like a&nbsp;duck and quacks like a&nbsp;duck, I&nbsp;call that&nbsp;bird a&nbsp;duck.</em><br>
&ndash;&nbsp;James Whitcomb Riley</p>

<h3 id="embedding-delegation">Embedding (delegation)</h3>

<p>Embedding a type as an anonymous field may be used to implement a form of subtyping.</p>

<pre><code>type MySubType struct {
    MyType
    j int
}

func (p *MySubType) Get() int {
    p.j++
    return p.MyType.Get()
}
</code></pre>

<p>This effectively implements <code>MySubType</code> as a subtype of
<code>MyType</code>.</p>

<pre><code>func f2() {
    var p MySubType
    GetAndSet(&amp;p)
}
</code></pre>

<p>The <code>Set</code> method is inherited from <code>MyType</code>,
because methods associated with the anonymous field are promoted
to become methods of the enclosing type.</p>

<p>In this case, because <code>MySubType</code> has an anonymous field
of type <code>MyType</code>, the methods of <code>MyType</code> also
become methods of <code>MySubType</code>.
The <code>Get</code> method was overridden,
and the <code>Set</code> method was inherited.</p>

<p>This is not the same as a subclass in Java, but a form of <em>delegation</em>.
When a method of an anonymous field is called, its receiver is the field,
not the surrounding struct. In other words, methods on anonymous fields
are not dynamically dispatched. When you want the equivalent of Java’s
dynamic method lookup, use an interface.</p>

<pre><code>func f3() {
    var v MyInterface

    v = new(MyType)
    v.Get() <span class="comment">// Call the Get method for *MyType.</span>

    v = new(MySubType)
    v.Get() <span class="comment">// Call the Get method for *MySubType.</span>
}</code></pre>

<h3 id="type-assertions">Type assertions</h3>

<p>A variable that has an interface type may be converted to have a
different interface type using a <a href="/golang/type-assertion-switch/">type&nbsp;assertion</a>.
This is implemented dynamically at run time. Unlike Java, there does not
need to be any declared relationship between the two interfaces.</p>

<pre><code>type Printer interface {
    Print()
}

func f4(x MyInterface) {
    x.(Printer).Print() <span class="comment">// type assertion to Printer</span>
}</code></pre>

<p>The conversion to <code>Printer</code> is entirely dynamic.
It will work as long as the <em>dynamic type</em> of x
(the actual type of the value stored in <code>x</code>)
defines a <code>Print</code> method.</p>

<h2 id="errors">Errors</h2>

<p>Where Java typically uses exceptions, Go has two different mechanisms:</p>

<ul>
<li>most functions return <a href="/golang/errors-explained/">errors</a>;</li>
<li>only truly unrecovorable conditions, such as an out-of-range index, produce run-time exceptions.</li>
</ul>

<p>Go’s multivalued return makes it easy to return a detailed error message
alongside the normal return value. By convention, such messages
have type <code>error</code>, a simple built-in interface.</p>

<pre><code>type error interface {
    Error() string
}
</code></pre>

<p>For example, the <code>os.Open</code> function returns a non-nil
<code>error</code> value when it fails to open a file.</p>

<pre><code>func Open(name string) (file *File, err error)
</code></pre>

<p>The following code uses <code>os.Open</code> to open a file.
If an <code>error</code> occurs it calls <code>log.Fatal</code>
to print the error message and stop.</p>

<pre><code>f, err := os.Open("filename.ext")
if err != nil {
    log.Fatal(err)
}
<span class="comment">// do something with the open *File f</span></code></pre>

<p>The <code>error</code> interface requires only an <code>Error</code> method,
but specific <code>error</code> implementations often have additional methods,
allowing callers to inspect the details of the error.</p>

<h2 id="panic-and-recover">Panic and recover</h2>

<p>A <a href="/golang/panic-explained/">panic</a> is a run-time error
that unwinds the stack of the goroutine,
running any deferred functions along the way,
and then stops the program.</p>

<p>Panics are similar to Java exceptions,
but are only intended for run-time errors,
such as following a <code>nil</code> pointer or
attempting to index an array out of bounds.
To signify events such as end-of-file, Go programs use the built-in
<code>error</code> type as <a href="#errors">described above</a>.</p>

<p>The built-in function <a href="/golang/recover-from-panic/"><code>recover</code></a> can be used to regain
control of a panicking goroutine and resume normal execution:</p>

<ul>
<li>a call to <code>recover</code> stops the unwinding and returns
the argument passed to <code>panic</code>.</li>
</ul>

<p>Because the only code that runs while unwinding is inside deferred functions,
<code>recover</code> is only useful inside deferred functions.
If the goroutine is not panicking,
<code>recover</code> returns&nbsp;<code>nil</code>.</p>

<h2 id="goroutines-and-channels">Goroutines and channels</h2>

<!-- CC BY-NC-ND 2.0: http://www.flickr.com/photos/un_photo/5853737946/ -->

<div><img itemprop="image" src="/golang/bouncing-balls.jpg" alt="Bouncing balls" ></div>

<h3 id="goroutines">Goroutines</h3>

<p>Go permits starting a new thread of execution, a goroutine,
using the <code>go</code> statement.
It runs a function in a different, newly created, <a href="/golang/goroutines-explained/">goroutine</a>.
All goroutines in a single program share the same address space.</p>

<p>Goroutines are lightweight,
costing little more than the allocation of stack space.
The stacks start small and grow by allocating and freeing
heap storage as required.
Internally goroutines act like coroutines that are multiplexed
among multiple operating system threads.</p>

<pre><code>go list.Sort() <span class="comment">// Run list.Sort in parallel; don’t wait for it.</span></code></pre>

<p>Go has function literals, which can act as <a href="/golang/anonymous-function-literal-lambda-closure/">closures</a>
and are powerful when coupled with the <code>go</code> statement.</p>

<pre><code><span class="comment">// Publish prints text to stdout after the given time has expired.</span>
func Publish(text string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(text)
    }() <span class="comment">// Note the parentheses. We must call the function.</span>
}</code></pre>

<p>The variables <code>text</code> and <code>delay</code>
are shared between the surrounding function and the function literal;
they survive as long as they are accessible.</p>

<h3 id="channels">Channels</h3>

<p>A <a href="/golang/channels-explained/">channel</a> provides a mechanism for two goroutines to synchronize
execution and communicate by passing a value of a specified
element type.
The <code>&lt;-</code> operator specifies the channel direction,
send or receive. If no direction is given, the channel is bi-directional.</p>

<pre><code>chan Sushi     <span class="comment">// can be used to send and receive values of type Sushi</span>
chan<- float64 <span class="comment">// can only be used to send float64s</span>
<-chan int     <span class="comment">// can only be used to receive ints</span></code></pre>

<p>Channels are a reference type and are allocated with make.</p>

<pre><code>ic := make(chan int)       <span class="comment">// unbuffered channel of ints</span>
wc := make(chan *Work, 10) <span class="comment">// buffered channel of pointers to Work</span></code></pre>

<p>To send a value on a channel,
use <code>&lt;-</code> as a binary operator.
To receive a value on a channel, use it as a unary operator.</p>

<pre><code>ic <- 3      <span class="comment">// Send 3 on the channel.</span>
work := <-wc <span class="comment">// Receive a pointer to Work from the channel.</span></code></pre>

<ul>
<li>If the channel is unbuffered,
the sender blocks until the receiver has received the value.</li>
<li>If the channel has a buffer,
the sender blocks only until the value has been copied to the buffer;
if the buffer is full,
this means waiting until some receiver has retrieved a value.</li>
<li>Receivers block until there is data to receive.</li>
</ul>

<p>The <code>close</code> function records that no more values
will be sent on a channel:</p>

<ul>
<li>After calling <code>close</code>,
and after any previously sent values have been received,
receive operations will return a zero value without blocking.</li>
<li>A multi-valued receive operation additionally returns
an indication of whether the channel is closed.</li>
</ul>

<pre><code>ch := make(chan string)
go func() {
    ch <- "Hello!"
    close(ch)
}()
fmt.Println(<-ch) <span class="comment">// Print "Hello!".</span>
fmt.Println(<-ch) <span class="comment">// Print the zero value "" without blocking.</span>
fmt.Println(<-ch) <span class="comment">// Once again print "".</span>
v, ok := <-ch     <span class="comment">// v is "", ok is false.</span></code></pre>

<p>In the next example we let the <code>Publish</code> function
return a channel, which is used to broadcast a message when
the text has been published.</p>

<pre><code><span class="comment">// Publish prints text to stdout after the given time has expired.</span>
<span class="comment">// It closes the wait channel when the text has been published.</span>
func Publish(text string, delay time.Duration) (wait <-chan struct{}) {
    ch := make(chan struct{})
    go func() {
        time.Sleep(delay)
        fmt.Println(text)
        close(ch)
    }()
    return ch
}</code></pre>

<p>This is how you might use this <code>Publish</code> function.</p>

<pre><code>wait := Publish("important news", 2 * time.Minute)
<span class="comment">// Do some more work.</span>
<-wait <span class="comment">// blocks until the text has been published</span></code></pre>

<h3 id="select-statement">Select statement</h3>

<p>The <a href="/golang/select-explained/">select&nbsp;statement</a> is the final tool in Go’s concurrency toolkit. It chooses which of a set of possible communications will proceed:</p>

<ul>
<li>if any of the communications can proceed, one of them is randomly
chosen and the corresponding statements are executed;</li>
<li>otherwise, if there is no default case,
the statement blocks until one of the communications can complete.</li>
</ul>

<p>Here is a toy example showing how the select statement can
be used to implement a random number generator.</p>

<pre><code>rand := make(chan int)
for { <span class="comment">// Send random sequence of bits to rand.</span>
    select {
    case rand <- 0: <span class="comment">// note: no statement</span>
    case rand <- 1:
    }
}</code></pre>

<p>Somewhat more realistically, here is how a select statement
could be used to set a time limit on a receive operation.</p>

<pre><code>select {
case news := &lt;-AFP:
    fmt.Println(news)
case &lt;-time.After(time.Minute):
    fmt.Println(&quot;Time out: no news in one minute.&quot;)
}
</code></pre>

<p>The function <code>time.After</code> is part of the standard library;
it waits for a specified time to elapse and then sends the current time
on the returned channel.</p>

<h2 id="hello-server-example">Hello server (example)</h2>

<p>We end with a small example to show how the pieces fit together.
The <code>server</code> package implements a server, which accepts <code>Work</code> requests
through a channel:</p>

<ul>
<li>each request is served in a separate goroutine,</li>
<li>the <code>Work</code> struct itself contains a channel used to return a result.</li>
</ul>

<pre><code>package server

import "log"

<span class="comment">// New creates a new server that accepts Work requests</span>
<span class="comment">// through the req channel.</span>
func New() (req chan<- *Work) {
    wc := make(chan *Work)
    go serve(wc)
    return wc
}

type Work struct {
    Op    func(int, int) int
    A, B  int
    Reply chan int <span class="comment">// Server sends result on this channel.</span>
}

func serve(wc <-chan *Work) {
    for w := range wc {
        go safelyDo(w)
    }
}

func safelyDo(w *Work) {
    <span class="comment">// Regain control of a panicking goroutine to avoid</span>
    <span class="comment">// killing the other executing goroutines.</span>
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(w)
}

func do(w *Work) {
    w.Reply <- w.Op(w.A, w.B)
}</code></pre>

<p>This is how you might use it.</p>

<pre><code>package server_test

import (
    "fmt"
    "server"
    "time"
)

func main() {
    s := server.New()

    divideByZero := &server.Work{
        Op:    func(a, b int) int { return a / b },
        A:     100,
        B:     0,
        Reply: make(chan int),
    }
    s <- divideByZero

    select {
    case res := <-divideByZero.Reply:
        fmt.Println(res)
    case <-time.After(time.Second):
        fmt.Println("No result in one second.")
    }
    <span class="comment">// Output: No result in one second.</span>
}</code></pre>


<h3>Further reading</h3>

<div><a href="/golang/tutorials/"><img src="/golang/learn-to-write-thumb.jpg" title="Go tutorials"></a></div>

<p style="margin-top:0;"><a href="/golang/tutorials/">Tutorials</a> for beginners and experienced developers alike: best practices and production-quality code examples.</p>
<p style="margin-top:2em;"><span style="position:relative;bottom:12px;"><b>Share<span class="extra-content"> this page</span>:</b></span>&nbsp;&nbsp;
<a href="https://twitter.com/share?url=https%3a%2f%2fyourbasic.org%2fgolang%2fgo-java-tutorial%2f&amp;text=Java%20to%20Go%20in-depth%20tutorial&amp;via=yourbasic%5forg" title="Share on Twitter"><img width="40px" src="/res/twitter-logo.svg"></a>&nbsp;&nbsp;
<a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fyourbasic.org%2fgolang%2fgo-java-tutorial%2f" title="Share on Facebook"><img width="36px" src="/res/facebook-logo.svg"></a>&nbsp;&nbsp;&nbsp;
<a href="https://www.reddit.com/submit?url=https%3a%2f%2fyourbasic.org%2fgolang%2fgo-java-tutorial%2f&amp;title=Java%20to%20Go%20in-depth%20tutorial" title="Share on Reddit"><img width="36px" src="/res/reddit-logo.svg"></a>&nbsp;&nbsp;&nbsp;
<span style="position:relative;bottom:2px;" class="small-content"><a href="mailto:?subject=Java%20to%20Go%20in-depth%20tutorial&body=https%3a%2f%2fyourbasic.org%2fgolang%2fgo-java-tutorial%2f" title="Share by mail"><img width="30px" src="/res/mail-logo.svg"></a></span></p>


</article>
<aside>

    
  <h2>Related</h2>

  <div class="reference">
    <a href="/golang/getting-started-hello-world/">4 key Go resources to get you started</a>
    <div class="desc">How to write &#39;Hello world&#39; and get started with Go programming: try it out, learn the basics, install the tools, start a project.</div>
    <div class="source">yourbasic.org</div>
  </div>

  <div class="reference">
    <a href="https://talks.golang.org/2015/go-for-java-programmers.slide#1">Go for Java Programmers</a>
    <div class="source"></div>
    <div class="author">Sameer Ajmani</div>
  </div>

  <div class="reference">
    <a href="/golang/packages-explained/">Packages in a nutshell</a>
    <div class="desc">Every Go program is made up of packages and each package has an import path: package names, declarations, resolving name conflicts, dot imports, installation, documentation.</div>
    <div class="source">yourbasic.org</div>
  </div>

  <div class="reference">
    <a href="/golang/errors-explained/">Error handling explained</a>
    <div class="desc">Go uses return values that implement the error interface to indicate errors.</div>
    <div class="source">yourbasic.org</div>
  </div>

  <div class="reference">
    <a href="/golang/inheritance-object-oriented/">Inheritance and OOP: Go one better</a>
    <div class="desc">Object-oriented programming in Go: How to get the benefits of inheritance (code reuse, polymorphism and dynamic dispatch) with composition, interfaces and embedding.</div>
    <div class="source">yourbasic.org</div>
  </div>

  <div class="reference">
    <a href="/golang/constructor-best-practice/">Constructors deconstructed</a>
    <div class="desc">Best practice in Go is to use suitable zero values and factories instead of constructors.</div>
    <div class="source">yourbasic.org</div>
  </div>

  <div class="reference">
    <a href="/golang/http-server-example/">HTTP server example</a>
    <div class="desc">How to implement a basic HTTP web server in Go with client requests and responses.</div>
    <div class="source">yourbasic.org</div>
  </div>

  <div class="reference">
    <a href="/golang/concurrent-programming/">Concurrent programming</a>
    <div class="desc">This tutorial covers concurrency patterns, goroutines, channels, deadlock, data race, timer, ticker, waitgroup, and efficient parallel computation.</div>
    <div class="source">yourbasic.org</div>
  </div>

  <h2>Follow on Twitter</h2>
  <ul class="none">
    <li><span><a href="https://twitter.com/yourbasic_org">
    <img width="22px" src="/res/twitter-logo.svg" title="Follow yourbasic.org on Twitter"></a></span>
    <a href="https://twitter.com/yourbasic_org">One useful golang fact per&nbsp;day</a></li>
  </ul>


  <h2>Most Read</h2>
  <ul class="none">
  
    <li><a href="/golang/gotcha/">Go gotcha: newbie or ninja?</a></li>

    <li><a href="/golang/blueprint/">Go blueprints: code for common tasks</a></li>

    <li><a href="/golang/build-append-concatenate-strings-efficiently/">How to best use a string builder</a></li>

    <li><a href="/golang/concurrent-programming/">Concurrent programming</a></li>

    <li><a href="/golang/inheritance-object-oriented/">Inheritance and OOP: Go one better</a></li>

  </ul>
  
  <p><a href="/golang/"><strong>See all 191 Go articles</strong></a></p>

</aside>
</main>

<footer>
  This work is licensed under&nbsp;a&nbsp;<a rel="license" alt="CC BY 3.0"
  href="http://creativecommons.org/licenses/by/3.0/"><span
  style="font-size:smaller;">CC&nbsp;BY&nbsp;3.0</span>&nbsp;license</a>.
</footer>
</body>
</html>
